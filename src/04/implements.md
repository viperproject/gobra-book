# Implementation proofs (`implements`)

In Gobra, a concrete type used as the underlying type of an interface value must be a [behavioral subtype](./behavioral.md) of the interface.
An _implementation proof_ is required when Gobra cannot infer this automatically.


As an example, we consider the interface `Bounded` with a single method `Bounds` that returns a bounding rectangle.
Additionally, a `Mem` predicate is defined to abstract memory access.
``` go
{{#include ./imageSimple.go:Bounded}}
```
We implement `Bounded` for the type `(*Alpha16Image)`.
With the implementation of `Bounds` and the predicate `Mem`, 
`(*Alpha16Image)` fulfils all syntactic requirements for the `Bounded` interface.
``` go
{{#include ./imageSimple.go:Alpha16ImageImpl}}
```
<!-- TODO: rename Alpha16Image to not confuse? maybe simplify struct and Mem pred -->

With the statement `T implements I` for a type `T` and interface type `I` we check whether `T` is a behavioral subtype of `I`.

Gobra tries an autogenerated proof, which may fail as seen in the following snippet:

``` go
// @ (*Alpha16Image) implements Bounded
```
``` text
ERROR Generated implementation proof (*Alpha16Image implements interface{ Bounds }) failed. Precondition of call to implementation method might not hold. 

Permission to p.Rect might not suffice.
```

The above failed since, to obtain
`acc(&p.Rect, 1/2)` from the interface's precondition `acc(Mem(), 1/2)` requires folding a predicate instance.
Gobra currently does not attempt to show this.

We give an implementation proof following after the `implements` keyword, 
where we must show that the precondition of the implementation and the postcondition of the interface method.
``` go
{{#include ./imageSimple.go:BoundsProof}}
```

For each method, we give the signature and proof annotations in the body.
Note that in the implementation proof the contract is not repeated.
The precondition and postcondition comes from the contract of the interface.
At the moment, implementation proofs are heavily syntactically restricted.
Besides a call to the implementation method where, 
we may only fold predicates and use assert statements.

In this case, after `unfold acc(p.Mem(), 1/2)` the precondition of the implementation method holds, and we may call `p.Bounds()` and must assign the out-parameter.
After `fold acc(p.Mem(), 1/2)`, the postcondition of the interface method holds.

For a `pure` function, the body must be a single expression, so one might have to work with `unfolding`.


## Predicates in implementation proofs
Predicates defined for an interface must be declared for the implementations.
When the implementing type is not the receiver of the predicate or the name of the predicate differs,
the correct predicate must be assigned in the implementation proof.

In the above example, we declared the predicate `(p *Alpha16Image) Mem()` which required no changes in the implementation proof.
Alternatively, consider we defined the predicate `MyMem(p *Alpha16Image)`.
Then, we must add the highlighted line to the implementation proof:
``` go
/*@
pred MyMem(p *Alpha16Image) {
	acc(p) && forall i int :: {&p.Pix[i]} 0 <= i && i < len(p.Pix) ==> acc(&p.Pix[i])
}
@*/

/*@
(*Alpha16Image) implements Bounded {

	pred Mem := MyMem	// <--- assign the predicate

	(p *Alpha16Image) Bounds() (r Rectangle) {
		unfold acc(MyMem(p), 1/2) // instead of p.Mem()
		r = p.Bounds()
		fold acc(MyMem(p), 1/2)	  // instead of p.Mem()
		return
	}
}
@*/
```

### Implementation proof in different packages
An implementation proof may be placed in another package than the implementation.
Similar to Go, where it is not possible to define new methods on a type from another package, we cannot define a predicate with a receiver from a different package.
For example, in the package `main` we cannot declared the predicate `pred (x *image.Gray) Mem()`, and must resort to something like `pred Mem(x *image.Gray)`.
Then the predicate must be assigned in the implementation proof as described above.

An example of this can be found [here](https://github.com/viperproject/gobra/blob/master/src/test/resources/regressions/features/interfaces/counterStream.gobra).


## Trivial implementation proofs

Alternatively, we can change the contract of `(p *Alpha16Image) Bounds()` to match the contract in the interface:
``` go
{{#include ./imageSimple.go:ImageBounds}}
```
Then, we can omit the implementation proof but instead have to fold and unfold the `Mem` predicate.
``` go
// @ preserves acc(p.Mem(), 1/2)
func (p *Alpha16Image) Bounds() (r Rectangle) {
	// @ unfold acc(p.Mem(), 1/2)
	r = p.Rect
	// @ fold acc(p.Mem(), 1/2)
	return
}
```

  

## Full example
``` go
{{#include ./imageSimple.go:all}}
```
